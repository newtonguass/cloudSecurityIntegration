{
    "AWSTemplateFormatVersion": "2010-09-09",
    "Description": "creat 2 lambda that send GuardDuty and Security Hub finding to Sentinel. You need to have Sentinel workspace and key encrypted in AWS secrets manager first. Then retrieve the arn of the secret as the parameter",
    "Parameters": {
        "RecurringScheduleCron": {
            "Description": "Cron expression for scheduling the Security Hub.",
            "Default": "cron(0 0 * * ? *)",
            "Type": "String"
        },
        "SentinelKeyARN":{
            "Description": "The ARN Sentinel Secret stored in the AWS secrets manager",
            "Type": "String",
            "AllowedPattern": "^arn:aws:secretsmanager:[a-zA-Z0-9\\-\\:]+"
        },
		"checkTheRoleForLambdaExisting":{
			"Type":"String",
			"Description":"The template will create a role for lambda, you need to check the role existing or not, or the creation will fail.",
			"AllowedValues": ["existing", "not_existing"],
            "AllowedPattern": "(existing)|(not_existing)"
		},
        "existingRoleARNForLambda":{
            "Description": "The ARN of existing role for lambda. If there is no role, then left it blank",
            "Type": "String",
            "AllowedPattern": "(^arn:aws:iam[a-zA-Z0-9\\-\\:\\/]+)|(^$)"
        }
    },
    "Metadata": {
        "AWS::CloudFormation::Interface": {
            "ParameterGroups": [
                {
                    "Label": {
                        "default": "Parameters"
                    },
                    "Parameters": [
                        "RecurringScheduleCron",
                        "SentinelKeyARN",
						"checkTheRoleForLambdaExisting",
                        "existingRoleARNForLambda"
                    ]
                }
            ],
            "ParameterLabels" : {
                "RecurringScheduleCron": {"default": "CloudWatch Cron Expression"},
                "SentinelKeyARN": {"default": "ARN of Sentinel Key stored in secrets manager"},
                "checkTheRoleForLambdaExisting": {"default": "Check for the role for lambda existing or not"},
                "existingRoleARNForLambda": {"default": "The ARN of existing role for lambda."}
        }
    }},
	"Conditions":{
		"createRole":{
			"Fn::Equals": [
                {
                    "Ref": "checkTheRoleForLambdaExisting"
                },
                "not_existing"
            ]
		},
		"addPolicy":{
			"Fn::Equals": [
                {
                    "Ref": "checkTheRoleForLambdaExisting"
                },
                "existing"
            ]
		}
	},
    "Resources" : {
        "cloudWatchTriggerSecurityHubLambdaDaily": {
            "Type": "AWS::Events::Rule",
            "Properties": {
                "Name": "cloudWatchTriggerSecurityHubLambdaDaily",
                "Description": "Triggers the Recurring Security Hub summary email",
                "ScheduleExpression": {"Ref": "RecurringScheduleCron"},
                "Targets": [
                    {
                        "Arn": {
                            "Fn::GetAtt": [
                                "lambdaSendSecurityHubDaily",
                                "Arn"
                            ]
                        },
                        "Id": "1"
                    }
                ]
            }
        },
        "cloudWatchGuarddutyTriggerLambda": {
            "Type": "AWS::Events::Rule",
            "Properties": {
                "Name": "cloudWatchGuarddutyTriggerLambda",
                "Description": "When GuardDuty has finding, trigger lambda function",
                "EventPattern":	{
                  "source": [
                    "aws.guardduty"
                  ]
                },
                "Targets": [
                    {
                        "Arn": {
                            "Fn::GetAtt": [
                                "lambdaSendGuardDutyFindingToSentinel",
                                "Arn"
                            ]
                        },
                        "Id": "1"
                    }
                ]
            }
        },
        "permissionCloudWatchSchedule": {
            "Type": "AWS::Lambda::Permission",
            "Properties": {
                "Action": "lambda:InvokeFunction",
                "FunctionName": {
                    "Fn::GetAtt": [
                        "lambdaSendSecurityHubDaily",
                        "Arn"
                    ]
                },
                "Principal": "events.amazonaws.com",
                "SourceArn": {
                    "Fn::GetAtt": [
                        "cloudWatchTriggerSecurityHubLambdaDaily",
                        "Arn"
                    ]
                }
            }
        },
        "permissionCloudWatchTriggerLambda": {
            "Type": "AWS::Lambda::Permission",
            "Properties": {
                "Action": "lambda:InvokeFunction",
                "FunctionName": {
                    "Fn::GetAtt": [
                        "lambdaSendGuardDutyFindingToSentinel",
                        "Arn"
                    ]
                },
                "Principal": "events.amazonaws.com",
                "SourceArn": {
                    "Fn::GetAtt": [
                        "cloudWatchGuarddutyTriggerLambda",
                        "Arn"
                    ]
                }
            }
        },
        "RoleLambdaForSentinel": {
            "Type": "AWS::IAM::Role",
			"Condition": "createRole",
            "Properties": {
              "RoleName":"RoleLambdaForSentinel",
              "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [{
                    "Effect": "Allow",
                    "Principal": {"Service": ["lambda.amazonaws.com"]},
                    "Action": ["sts:AssumeRole"]
                }]
              },
               "Policies": [{
                "PolicyName": {"Fn::Join":["-", ["getSentinelKey",{"Ref": "AWS::Region"}]]},
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [{
                        "Effect": "Allow",
                        "Action": [
                            "secretsmanager:GetResourcePolicy",
                            "secretsmanager:GetSecretValue",
                            "secretsmanager:DescribeSecret",
                            "secretsmanager:ListSecretVersionIds"
                        ],
                        "Resource": {"Ref": "SentinelKeyARN"}
                  }
                ]
                }
              }],
              "ManagedPolicyArns":[
                  "arn:aws:iam::aws:policy/AWSSecurityHubReadOnlyAccess"
              ],
              "Path": "\/"
            }
        },
        "addPolicyToRoleLambdaForSentinel":{
			"Condition": "addPolicy",
			"Type": "AWS::IAM::Policy",
			"Properties": {
				"PolicyName": {"Fn::Join":["-", ["getSentinelKey",{"Ref": "AWS::Region"}]]},
				"PolicyDocument": {
					"Version": "2012-10-17",
					"Statement": [{
						"Effect": "Allow",
                        "Action": [
						"secretsmanager:GetResourcePolicy",
						"secretsmanager:GetSecretValue",
						"secretsmanager:DescribeSecret",
						"secretsmanager:ListSecretVersionIds"
                        ],
                        "Resource": {"Ref": "SentinelKeyARN"}
						}
					]
				},
                "Roles":[{ "Fn::Select" : [ "1", { "Fn::Split": ["\/", {"Ref" : "existingRoleARNForLambda"}] } ]  }]
			}
		},
        "lambdaSendSecurityHubDaily": {
            "Type": "AWS::Lambda::Function",
            "Properties": {
                "Code": {
                    "ZipFile": {
                        "Fn::Join": [
                            "\n",
                            [
                              "import json",
                              "import boto3",
                              "import datetime",
                              "import hashlib",
                              "import hmac",
                              "import base64",
                              "import urllib3.poolmanager",
                              "from datetime import date",
                              "from datetime import datetime as datetime_",
                              "",
                              "#Solve the problem of datetime in json object",
                              "class ComplexEncoder(json.JSONEncoder):",
                              "    def default(self, obj):",
                              "        if isinstance(obj, datetime_):",
                              "            return obj.strftime('%Y-%m-%d %H:%M:%S')",
                              "        elif isinstance(obj, date):",
                              "            return obj.strftime('%Y-%m-%d')",
                              "        else:",
                              "            return json.JSONEncoder.default(self, obj)",
                              "# offical tutor: https://docs.microsoft.com/en-us/azure/azure-monitor/logs/data-collector-api",
                              "# customer_id is workspace id, shared_key is primary key",
                              "def build_signature(customer_id, shared_key, date, content_length, method, content_type, resource):",
                              "    x_headers = 'x-ms-date:' + date",
                              "    string_to_hash = method + '\\n' + str(content_length) + '\\n' + content_type + '\\n' + x_headers + '\\n' + resource",
                              "    bytes_to_hash = bytes(string_to_hash, encoding='utf-8')",
                              "    decoded_key = base64.b64decode(shared_key)",
                              "    encoded_hash = base64.b64encode(hmac.new(decoded_key, bytes_to_hash, digestmod=hashlib.sha256).digest()).decode()",
                              "    authorization = 'SharedKey {}:{}'.format(customer_id,encoded_hash)",
                              "    return authorization",
                              "# Build and send a request to the POST API",
                              "def post_data(customer_id, shared_key, body, log_type):",
                              "    method = 'POST'",
                              "    content_type = 'application/json'",
                              "    resource = '/api/logs'",
                              "    rfc1123date = datetime.datetime.utcnow().strftime('%a, %d %b %Y %H:%M:%S GMT')",
                              "    content_length = len(body)",
                              "    signature = build_signature(customer_id, shared_key, rfc1123date, content_length, method, content_type, resource)",
                              "    uri = 'https://' + customer_id + '.ods.opinsights.azure.com' + resource + '?api-version=2016-04-01'",
                              "",
                              "    headers = {",
                              "        'content-type': content_type,",
                              "        'Authorization': signature,",
                              "        'Log-Type': log_type,",
                              "        'x-ms-date': rfc1123date",
                              "    }",
                              "    http = urllib3.PoolManager()",
                              "    r = http.request(",
                              "        'POST',",
                              "        uri,",
                              "        body=body,",
                              "        headers=headers)",
                              "    if (r.status >= 200 and r.status <= 299):",
                              "        return 'Accepted'",
                              "    else:",
                              "        return 'Response code: {}'.format(r.status_code)",
                              "def lambda_handler(event, context):",
                              "    client = boto3.client('secretsmanager')",
                              {"Fn::Join":["", ["    response = client.get_secret_value(SecretId='",{"Ref": "SentinelKeyARN"}, "')"]]},
                              "    secret = json.loads(response['SecretString'])",
                              "    customer_id = secret['workspaceID']",
                              "    shared_key  = secret['primaryKey']",
                              "    log_type = 'securityhub'",
                              "    client = boto3.client('securityhub')",
                              "    result = 'Success'",
                              "    stat = 0",
                              "    Filters={",
                              "        'UpdatedAt': [",
                              "            {",
                              "                'DateRange': {",
                              "                    'Value': 1,",
                              "                    'Unit': 'DAYS'",
                              "                }",
                              "            },",
                              "        ]",
                              "    }",
                              "    paginator  = client.get_paginator('get_findings')",
                              "    page_iterator = paginator.paginate(Filters=Filters,",
                              "                                      PaginationConfig={'PageSize': 100})",
                              "    for page in page_iterator:",
                              "        body = json.dumps(page['Findings'])",
                              "        sending = post_data(customer_id, shared_key, body, log_type)",
                              "        stat+=len(page['Findings'])",
                              "    log_type = 'securityhub_control'",
                              "    standard = client.get_enabled_standards()",
                              "    log_type='securityhubControl'",
                              "    for i in standard['StandardsSubscriptions']:",
                              "        result  = client.describe_standards_controls(StandardsSubscriptionArn=i['StandardsSubscriptionArn'])",
                              "        body = json.dumps(result['Controls'], cls=ComplexEncoder)",
                              "        sending = post_data(customer_id, shared_key, body, log_type)",
                              "        stat+=len(body)",
                              "    return {",
                              "        'statusCode': 200,",
                              "        'body': json.dumps(stat)",
                              "    }"
                            ]
                        ]
                    }
                },
                "FunctionName":"lambdaSendSecurityHubDaily",
                "Handler": "index.lambda_handler",
                "MemorySize": 256,
                "Runtime": "python3.7",
                "Timeout": "300",
                "Role": 
					{
					  "Fn::If" : [
						"createRole",
						{"Fn::GetAtt": [ "RoleLambdaForSentinel", "Arn" ]},
						{"Ref" : "existingRoleARNForLambda"}
					  ]
					}
			}},
        "lambdaSendGuardDutyFindingToSentinel": {
            "Type": "AWS::Lambda::Function",
            "Properties": {
                "Code": {
                    "ZipFile": {
                        "Fn::Join": [
                            "\n",
                            [
                              "import json", 
                              "import boto3",
                              "import datetime",
                              "import hashlib",
                              "import hmac",
                              "import base64",
                              "import urllib3.poolmanager",
                              "# offical tutor: https://docs.microsoft.com/en-us/azure/azure-monitor/logs/data-collector-api",
                              "# customer_id is workspace id, shared_key is primary key",
                              "def build_signature(customer_id, shared_key, date, content_length, method, content_type, resource):",
                              "    x_headers = 'x-ms-date:' + date",
                              "    string_to_hash = method + '\\n' + str(content_length) + '\\n' + content_type + '\\n' + x_headers + '\\n' + resource",
                              "    bytes_to_hash = bytes(string_to_hash, encoding='utf-8')",
                              "    decoded_key = base64.b64decode(shared_key)",
                              "    encoded_hash = base64.b64encode(hmac.new(decoded_key, bytes_to_hash, digestmod=hashlib.sha256).digest()).decode()",
                              "    authorization = 'SharedKey {}:{}'.format(customer_id,encoded_hash)",
                              "    return authorization",
                              
                              "# Build and send a request to the POST API",
                              "def post_data(customer_id, shared_key, body, log_type):",
                              "    method = 'POST'",
                              "    content_type = 'application/json'",
                              "    resource = '/api/logs'",
                              "    rfc1123date = datetime.datetime.utcnow().strftime('%a, %d %b %Y %H:%M:%S GMT')",
                              "    content_length = len(body)",
                              "    signature = build_signature(customer_id, shared_key, rfc1123date, content_length, method, content_type, resource)",
                              "    uri = 'https://' + customer_id + '.ods.opinsights.azure.com' + resource + '?api-version=2016-04-01'",
                              
                              "    headers = {",
                              "        'content-type': content_type,",
                              "        'Authorization': signature,",
                              "        'Log-Type': log_type,",
                              "        'x-ms-date': rfc1123date",
                              "    }",
                              "    http = urllib3.PoolManager()",
                              "    r = http.request(",
                              "        'POST',",
                              "        uri,",
                              "        body=body,",
                              "        headers=headers)",
                              "    #response = requests.post(uri,data=body, headers=headers)",
                              "    if (r.status >= 200 and r.status <= 299):",
                              "        return 'Accepted'",
                              "    else:",
                              "        return 'Response code: {}'.format(r.status_code)",
                              "def lambda_handler(event, context):", 
                              "    client = boto3.client('secretsmanager')", 
                              {"Fn::Join":["", ["    response = client.get_secret_value(SecretId='",{"Ref": "SentinelKeyARN"}, "')"]]},
                              "    secret = json.loads(response['SecretString'])",
                              "    customer_id = secret['workspaceID']",
                              "    shared_key  = secret['primaryKey']",
                              "    log_type = 'guardduty'",
                              "    body = json.dumps(event)",
                              "    result = post_data(customer_id, shared_key, body, log_type)",
                              "    return {",     
                              "    'statusCode': 200,",         
                              "    'body': json.dumps(result)",         
                              "    }"
                            ]
                        ]
                    }
                },
                "FunctionName":"lambdaSendGuardDutyFindingToSentinel",
                "Handler": "index.lambda_handler",
                "MemorySize": 256,
                "Runtime": "python3.7",
                "Timeout": "300",
                "Role": 
					{
					  "Fn::If" : [
						"createRole",
						{"Fn::GetAtt": [ "RoleLambdaForSentinel", "Arn" ]},
						{"Ref" : "existingRoleARNForLambda"}
					  ]
					}

            }
        }
    }
}
